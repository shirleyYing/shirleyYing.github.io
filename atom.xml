<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[fina's Blog]]></title>
  <subtitle><![CDATA[keep Calm]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://shirleyYing.com/"/>
  <updated>2019-01-20T07:39:05.332Z</updated>
  <id>https://shirleyYing.com/</id>
  
  <author>
    <name><![CDATA[zhangying]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2018_summary]]></title>
    <link href="https://shirleyYing.com/2019/01/20/2018-summary/"/>
    <id>https://shirleyYing.com/2019/01/20/2018-summary/</id>
    <published>2019-01-20T06:37:15.000Z</published>
    <updated>2019-01-20T07:39:05.332Z</updated>
    <content type="html"><![CDATA[<p>年终总结</p>
<a id="more"></a>
<h3 id="关于工作">关于工作</h3><p>2018，进入工作的第三个年头。可以算是里程碑式的一个节点了。</p>
<p>之前以为三个月就死掉的项目，却做了整整一年，明年还要接着做，卖给了客户，也经常要解决线上问题了，其实只是部署到客户企业的服务。凭借这个项目，拿到了工作中第一个五星，中间一次加薪也是历史最高。从师傅眼中的恨铁不成钢，到跟在别人后面打酱油，螺丝钉一样到处补，到如今一个人支撑整个项目的前端半年时间，再到成为一个小项目的前端负责人，招聘外包。对内分配任务，控制进度，对外沟通需求，排除问题，对上汇报。每件事情都让我既兴奋又害怕。索性一切发生的都如此迅速，简单通知了一声，就开始了紧张的开发，排期，pk 需求。只有在晚上 10 点后空荡荡的公交上，才有时间感叹这一切的变化。每每给他们找 bug，解决问题，都会想起当初的自己，看不懂错误提示，不搜索，当初怕不是要把师傅气死吧，怎么招来这么笨的实习生。</p>
<p>现在的我，再也不会面对 bug 不知所措了，想起曾经因为解决不了的问题，愁的睡不着觉的时光，终于过去了。现在才发现，狗子之前安慰我的话，都是对的，但当时的我，忙着自怨自艾，忙着逃避，一点也听不进去。经历了那场印象深刻的转岗风波，自己再也不是小白羊了，再也不会忍气吞声，面对质疑，大声回应，向领导寻求帮助。再也不会觉得难为情和害怕，工作而已，只要体现出自己的专业，没有人会说什么。累活可以干，该哭的时候就要哭，在合理范围内，决不能委屈自己。认清自己的角色，摆正位置，不然就只能让别人看笑话，或者自己窝火。</p>
<h3 id="关于学习">关于学习</h3><p>去年立的 flag,也算是没倒吧，最近一篇博客是 10 月份的。最近几个月太累，在家总是看电视。技术方面，这一年还是在做 react 相关。有点长进的部分，应该算是 node 了，在做的项目，不仅负责前端，还用 node 做了 server 层，直连 sql db，做了数据层，还学习了 elastic search 。学习了 es 语法来读取数据，研究了一下前后端分离，mock 数据，仔细看了 antd 的一个 mock 工具。 工作之外，确实没有太多，太懒了。</p>
<h3 id="关于生活">关于生活</h3><p>这一年的生活，完成了好几个立了很久的 flag。这是第一个觉得有生活的一年。虽然坚持的辛苦，但总算都是善始善终。</p>
<ol>
<li>年初报了一个减肥活动，两个月时间，瘦了 6 斤。每周一三五去健身房练莱美课程。体重变化不大，体脂率下降明显。很满意了。</li>
<li>9 月份报了英语流利说的每日外刊精读，坚持了一百天。</li>
<li>两年前就计划的舞蹈班，双十一报了，一口气就买了个三千块的卡，结果年末赶上年会跳舞，还是没时间去。两个月才去了 12 次。昨天老师说我有进步。美滋滋。总算是有个事情干了，不加班的周末，每天晚上去跳舞，也算很充实了。谁还不是美美的小姐姐~</li>
</ol>
<p>新年的计划还没想好。大概就是攒钱买房，晋升答辩。又是一个新的开始，别怕。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>年终总结</p>]]>
    
    </summary>
    
      <category term="life" scheme="https://shirleyYing.com/tags/life/"/>
    
      <category term="life" scheme="https://shirleyYing.com/categories/life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prettier+VScode 治好你的代码洁癖]]></title>
    <link href="https://shirleyYing.com/2018/10/01/prettier-format/"/>
    <id>https://shirleyYing.com/2018/10/01/prettier-format/</id>
    <published>2018-10-01T08:16:53.000Z</published>
    <updated>2018-10-01T08:36:46.000Z</updated>
    <content type="html"><![CDATA[<p>试想一个多人开发的项目，每次同步代码，看到各个风格迥异，换行空格混乱，4 格，2 格缩进交替上演的代码文件，分分钟逼死强迫症啊。忍无可忍只能拔枪相见了~~。统一的代码风格规范，对于多人开发的大项目一定是必不可少的，但是口头约定又是一定没有用的（nice 脸）。这时候就需要 Prettier 上场了，一个配置文件，配合 VScode，保存即格式化，你的同事都不需要知道代码风格是什么，，整个团队只要 clone 项目，自动保持统一风格。搞定！</p>
<a id="more"></a>
<h2 id="Prettier_是什么">Prettier 是什么</h2><blockquote>
<p>Prettier is an opinionated code formatter. It enforces a consistent style by parsing your code and re-printing it with its own rules that take the maximum line length into account, wrapping code when necessary.</p>
</blockquote>
<p>以上是 github 上的官方解释，其实就是简单的代码格式工具，和 esLint 不同在于，ESLint 只是一个代码质量工具(确保没有未使用的变量、没有全局变量，等等)。而 Prettier 只关心格式化文件(最大长度、混合标签和空格、引用样式等)。可见，代码格式统一的问题，交给 Prettirer 再合适不过了。和 Eslint 配合使用，风味更佳。</p>
<h2 id="Prettier_怎么用">Prettier 怎么用</h2><ul>
<li>编辑器插件</li>
<li>CLI 命令行</li>
</ul>
<h3 id="编辑器">编辑器</h3><p>这里介绍 VSCode 中如何配置 Prettier</p>
<h4 id="1-安装_Prettier_插件_Prettier_-_Code_formatter">1.安装 Prettier 插件 <a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" target="_blank" rel="noopener">Prettier - Code formatter</a></h4><p>安装插件后，调出系统设置就能看到 prettier 相关选项了，如图<br><img src="/imgs/prettier.jpeg" alt="prettier配置项"></p>
<h4 id="2-添加自定义配置文件-prettierrc">2.添加自定义配置文件.prettierrc</h4><p>作为项目的整体代码规范，如果依赖本地配置，显然是不科学的，所以需要<code>.prettierrc</code> 文件覆盖本地配置。我的配置文件如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"singleQuote"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"trailingComma"</span>: <span class="string">"es5"</span>,</span><br><span class="line">  <span class="attr">"printWidth"</span>: <span class="number">140</span>,</span><br><span class="line">  <span class="attr">"overrides"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"files"</span>: <span class="string">".prettierrc"</span>,</span><br><span class="line">      <span class="attr">"options"</span>: &#123; <span class="attr">"parser"</span>: <span class="string">"json"</span> &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，prettier 安装完毕，使用<code>shift+alt+f</code>就可格式化代码。当然每次手动格式化还是很费力啊，怎么办？自动保存。系统设置中增加<code>&quot;editor.formatOnSave&quot;: true</code>即可自动保存，还要注意的一点是，如果同时设置了<code>&quot;files.autoSave&quot;: &quot;autoSaveDelay&quot;,</code>保存及格式化会失效。<code>files.autoSave</code>配置成别的选项即可。</p>
<h4 id="3-editorConfig文件与-prettierrc_文件同时存在">3.<code>.editorConfig</code>文件与<code>.prettierrc</code> 文件同时存在</h4><p>另外，如果项目配置了<code>.editorConfig</code>文件，在配置了<code>&quot;editor.formatOnSave&quot;: true</code>后，如果项目成员没有安装 Prettier 插件，保存时就会读取<code>.editorConfig</code>文件，同样可以格式化代码。启用 Prettier 插件后，<code>.editorConfig</code>的配置就会失效，读取<code>.prettierrc</code> 文件的配置</p>
<h3 id="命令行">命令行</h3><p>命令行用法需要安装 prettier,<code>npm install prettier --save-dev</code>，使用<code>prettier write **.js</code> 就可以格式化文件。将添加到你的 NPM 脚本中，<code>prettier --write &#39;./src/**/*.js</code>,这样就可以批量格式化项目中的所有文件了。</p>
<h2 id="结语">结语</h2><p>Prettier 只关心代码格式，显然是不够的。项目中还是要引入 ESlint。两者配合才能使项目代码优雅健壮。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>试想一个多人开发的项目，每次同步代码，看到各个风格迥异，换行空格混乱，4 格，2 格缩进交替上演的代码文件，分分钟逼死强迫症啊。忍无可忍只能拔枪相见了~~。统一的代码风格规范，对于多人开发的大项目一定是必不可少的，但是口头约定又是一定没有用的（nice 脸）。这时候就需要 Prettier 上场了，一个配置文件，配合 VScode，保存即格式化，你的同事都不需要知道代码风格是什么，，整个团队只要 clone 项目，自动保持统一风格。搞定！</p>]]>
    
    </summary>
    
      <category term="JSformat Prettier" scheme="https://shirleyYing.com/tags/JSformat-Prettier/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[roadhog-api-doc 玩法介绍]]></title>
    <link href="https://shirleyYing.com/2018/09/02/roadhog-api-doc/"/>
    <id>https://shirleyYing.com/2018/09/02/roadhog-api-doc/</id>
    <published>2018-09-02T03:45:23.000Z</published>
    <updated>2018-09-02T10:41:59.000Z</updated>
    <content type="html"><![CDATA[<p>接口测试好用工具，roadhog-api-doc 用法介绍<br><a id="more"></a></p>
<p>最近工作中遇到了排期比较紧张的项目，前后端分离并行开发成为必然选择。所谓前后端分离，即约定好一套接口标准，前后端各自独立开发，就不会被对方的技术难点给阻塞住，从而保证项目进度。这样的并行开发看似美好，实际使用起来也遇到了不少痛点:</p>
<ol>
<li>在联调测试中，接口不稳定，甚至约定接口字段变化的现象时有发生。直接反应是页面报错或显示不正常，比较难快速定位问题。</li>
<li>约定的接口总是开后端开发自己约定，只言片语或零散的json文件，不能形成文档，不利于维护与交接。</li>
</ol>
<p>项目主要使用了组件库<code>ant-design</code>.以及基于此的中台前端解决方案 <code>ant-design-pro</code>. 该解决方案底层工具使用<code>roadhog</code>，该工具除了包装webpack，webpack-dev-server 完成构建,和开发中的自动同步构建，还增加了代理转发的功能，通过代理请求就能够轻松处理数据模拟的功能。使得在项目中可以轻松集成模拟数据。</p>
<p>当然只是使用模拟数据还是不够的，使用<code>roadhog-api-doc</code>自动生成文档工具，通过读取假数据配置文件，可以自动生成文档。恰当使用配置，指定ip，端口，还可以在文档上直接发起请求访问真实数据，自己写个循环脚本就可以批量测试接口啦。糟糕~ 是心动的感觉。</p>
<p>前戏这么久，终于进入正题了。下面进入使用攻略环节。</p>
<h3 id="基本使用">基本使用</h3><p><code>roadhog-api-doc</code> 主要是靠读取 <code>.roadhog.mock.js</code>文件生成文档。所有的mock数据都要写在这里。形式如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; postRule &#125; <span class="keyword">from</span> <span class="string">'./mock/rule'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; format &#125; <span class="keyword">from</span> <span class="string">'roadhog-api-doc'</span>;</span><br><span class="line"><span class="keyword">const</span> proxy = &#123;</span><br><span class="line">  <span class="string">'GET /api/currentUser'</span>: &#123;</span><br><span class="line">    <span class="comment">// 接口描述</span></span><br><span class="line">    $desc: <span class="string">"获取当前用户接口"</span>,</span><br><span class="line">    <span class="comment">// 接口参数</span></span><br><span class="line">    $params: &#123;</span><br><span class="line">      pageSize: &#123;</span><br><span class="line">        desc: <span class="string">'分页'</span>,</span><br><span class="line">        exp: <span class="number">2</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 接口返回</span></span><br><span class="line">    $body: &#123;</span><br><span class="line">      name: <span class="string">'momo.zxy'</span>,</span><br><span class="line">      avatar: imgMap.user,</span><br><span class="line">      userid: <span class="string">'00000001'</span>,</span><br><span class="line">      notifyCount: <span class="number">12</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'POST /api/rule'</span>: &#123;</span><br><span class="line">    $params: &#123;</span><br><span class="line">      pageSize: &#123;</span><br><span class="line">        desc: <span class="string">'分页'</span>,</span><br><span class="line">        exp: <span class="number">2</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    $body: postRule,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// format 函数用于保证本地的模拟正常，如果写了文档，这个函数转换是必要的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> format(proxy);</span><br></pre></td></tr></table></figure></p>
<p>生成结果如下<br><img src="/imgs/roadhog-api-doc.png" alt="api-doc"></p>
<p>文档中请求地址，参数，一应俱全。通过在mock接口中增加描述字段，就可以直接在文档中显示了。点击 send 按钮,及发送请求。弹框输出请求结果<br>使用 <code>roadhog-api-doc start [port]</code> 即启动服务，指定端口，相当于开发环境，自动监控文件变化刷新页面<br>使用 <code>roadhog-api-doc build [port]</code> 构建文档，输出到dist目录，生成 api.html, api.js, api.css 三个文件</p>
<h3 id="进阶使用">进阶使用</h3><p>输出了api文档，但是还想要请求真实环境地址，集中测试接口怎么办？<br>看了源码后发现，请求地址的ip部分写死了 <code>localhost</code>,只有端口可变。在<code>lib/</code>目录下，源码如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> configContent = <span class="string">`</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    port: "<span class="subst">$&#123;projectServerPort&#125;</span>",</span></span><br><span class="line"><span class="string">    docPort: "<span class="subst">$&#123;port&#125;</span>",</span></span><br><span class="line"><span class="string">    isStatic: <span class="subst">$&#123;isStatic&#125;</span>,</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line"></span><br><span class="line">    fs.writeFileSync(path.join(tempDir, <span class="string">'./src/config.js'</span>), configContent, <span class="string">'utf-8'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (projectServerPort) &#123;</span><br><span class="line">      <span class="keyword">const</span> mockjsContent = <span class="string">`</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  'GET /api/*': 'http://localhost:<span class="subst">$&#123;projectServerPort&#125;</span>/',</span></span><br><span class="line"><span class="string">  'POST /api/*': 'http://localhost:<span class="subst">$&#123;projectServerPort&#125;</span>/'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">      fs.writeFileSync(path.join(tempDir, <span class="string">'./.roadhogrc.mock.js'</span>), mockjsContent, <span class="string">'utf-8'</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>projectServerPort</code>是命令行输入的端口号，我们想要修改ip，需要修改一下源码。将localhost 改为参数，在命令行中输入，指定IP和端口号，就可以自由发起请求了。<br>修改代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockjsContent = <span class="string">`</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  'GET /api/*': '<span class="subst">$&#123;projectIP&#125;</span>:<span class="subst">$&#123;projectServerPort&#125;</span>/',</span></span><br><span class="line"><span class="string">  'POST /api/*': '<span class="subst">$&#123;projectIP&#125;</span>:<span class="subst">$&#123;projectServerPort&#125;</span>/'</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>启动命令改为<br><code>roadhog-api-doc start [port] [ip]</code><br><code>roadhog-api-doc build [port] [ip]</code></p>
<p>需要注意的是，start命令和build命令分别对应两个执行文件 start.js build.js 两个文件都要修改。</p>
<h3 id="总结">总结</h3><p><code>roadhog-api-doc</code> 的实现原理很简单，就是靠读取配置文件实现一个简单的页面。在<code>ant-design-pro</code>中，配合<code>roadhog</code>一起使用,可以使用一套mock数据，既可用于前端开发，又可生成接口文档。一次修改，两边同步，非常便捷。不用特别维护接口文档，为开发省了不少力气，也避免了接口文档因为年久失修而被丢弃的命运。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接口测试好用工具，roadhog-api-doc 用法介绍<br>]]>
    
    </summary>
    
      <category term="apiest roadhog-api-doc ant-design-pro" scheme="https://shirleyYing.com/tags/apiest-roadhog-api-doc-ant-design-pro/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MAC下mongodb 安装及权限配置]]></title>
    <link href="https://shirleyYing.com/2018/07/22/mongodb-install/"/>
    <id>https://shirleyYing.com/2018/07/22/mongodb-install/</id>
    <published>2018-07-22T15:03:06.000Z</published>
    <updated>2018-07-22T15:25:52.477Z</updated>
    <content type="html"><![CDATA[<p>mongodb 安装及用户配置流水账式记录<br><a id="more"></a><br>mac下直接使用了homeBrew安装。</p>
<h4 id="安装">安装</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew <span class="keyword">update</span> </span><br><span class="line">brew <span class="keyword">install</span> mongodb</span><br><span class="line">brew <span class="keyword">install</span> mongodb <span class="comment">--with-openssl //带TLS/SSL支持</span></span><br><span class="line">brew <span class="keyword">install</span> mongodb <span class="comment">--devel //获取最新版本的</span></span><br></pre></td></tr></table></figure>
<p>安装版本为 4.0<br>通过homebrew安装的会自动在<code>/usr/local/etc/</code>下创建<code>mongod.conf</code>文件。内容如下<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">systemLog:</span></span><br><span class="line"><span class="symbol">  destination:</span> file</span><br><span class="line"><span class="symbol">  path:</span> <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/var/</span>log<span class="meta-keyword">/mongodb/</span>mongo.log</span><br><span class="line"><span class="symbol">  logAppend:</span> true</span><br><span class="line"><span class="symbol">storage:</span></span><br><span class="line"><span class="symbol">  dbPath:</span> <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/var/</span>mongodb</span><br><span class="line"><span class="symbol">net:</span></span><br><span class="line"><span class="symbol">  bindIp:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，指定了log和数据库文件位置。</p>
<h4 id="启动">启动</h4><p>启动指令：<code>mongod --config /usr/local/etc/mongod.conf -auth</code><br>启动后的输出比以前少了不少。<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018<span class="string">-07</span><span class="string">-22</span>T22:58:03.137<span class="string">+0800</span> I CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols 'none'</span><br></pre></td></tr></table></figure></p>
<h4 id="登录创建用户">登录创建用户</h4><ol>
<li>为了使用账号密码登录，在上面的启动命令中，加了 <code>-auth</code> ，作用是开启权限验证。</li>
<li>切换到admin 数据库<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">db</span><span class="selector-class">.createUser</span>(&#123;</span><br><span class="line">     <span class="attribute">user</span>:<span class="string">"admin"</span>,</span><br><span class="line">     <span class="attribute">pwd</span>:<span class="string">"admin"</span>,</span><br><span class="line">     <span class="attribute">roles</span>:[&#123;</span><br><span class="line">         <span class="attribute">role</span>:<span class="string">"root"</span>,</span><br><span class="line">         <span class="attribute">db</span>:<span class="string">"admin"</span></span><br><span class="line">     &#125;]</span><br><span class="line"> &#125;)</span><br><span class="line">&gt; <span class="selector-tag">db</span><span class="selector-class">.auth</span>(<span class="string">"admin"</span>, <span class="string">"admin"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>创建最高权限的管理员</p>
<ol>
<li>切换到所在数据库，创建用户<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">db</span><span class="selector-class">.createUser</span>(&#123;<span class="attribute">user</span>:<span class="string">"user"</span>,<span class="attribute">pwd</span>:<span class="string">"123456"</span>,<span class="attribute">roles</span>:[&#123;<span class="attribute">role</span>:<span class="string">"dbOwner"</span>,<span class="attribute">db</span>:<span class="string">"mock"</span>&#125;]&#125;)</span><br><span class="line">&gt; <span class="selector-tag">db</span><span class="selector-class">.auth</span>(<span class="string">"user"</span>, <span class="string">"123456"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>mongodb 安装及用户配置流水账式记录<br>]]>
    
    </summary>
    
      <category term="mongodb" scheme="https://shirleyYing.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node多进程学习(一)]]></title>
    <link href="https://shirleyYing.com/2018/05/13/node-process/"/>
    <id>https://shirleyYing.com/2018/05/13/node-process/</id>
    <published>2018-05-13T01:48:02.000Z</published>
    <updated>2018-05-13T03:47:38.000Z</updated>
    <content type="html"><![CDATA[<p>node 多进程基础学习及demo<br><a id="more"></a></p>
<h2 id="基础概念">基础概念</h2><h3 id="cluster">cluster</h3><p><code>nodejs</code>在单个进程中运行单个实例，也就是只会占用一个cpu资源，但是为了进一步榨干计算机性能，想要利用计算机的多核同步计算，就要用到<code>cluster</code>,<code>cluster</code> 模块允许简单容易的创建共享服务器端口的子进程.</p>
<h3 id="worker">worker</h3><p>子进程实例，也叫工作进程，在一个主进程里，可以使用<code>cluster.workers</code>来获取Worker对象。在一个工作进程里，可以使用<code>cluster.worker</code>来获取Worker对象,执行监听方法等事件,只能在主进程中调用。</p>
<h3 id="方法">方法</h3><ol>
<li><code>cluster.fork()</code> 用来创建子进程，每调用一次，就会生成一个worker的id标识，保存在<code>cluster.workers</code>中</li>
<li><code>exit()</code> cluster和worker 都有这个方法<ul>
<li><code>cluster.exit</code>在任何工作进程关闭时，都会触发该方法，所以可以用来监听工作进程活跃状态，并重启工作进程。 </li>
<li><code>worker.exit</code>监听特定进程是否关闭</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'worker %d died (%s). restarting...'</span>,</span><br><span class="line">              worker.process.pid, signal || code);</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">worker.on(<span class="string">'exit'</span>, (code, signal) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (signal) &#123;</span><br><span class="line">    <span class="comment">// 引发进程被kill的信号名称（如'SIGHUP'）.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker was killed by signal: <span class="subst">$&#123;signal&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//若正常退出，表示退出代码.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`worker exited with error code: <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker success!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>send()</code> 用于主进程和子进程间的信息交换。主进程调用该方法可以给工作进程发送消息，工作进程调用，给主进程发送消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="keyword">const</span> worker = cluster.fork();</span><br><span class="line">  worker.send(<span class="string">'hi there'</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cluster.isWorker) &#123;</span><br><span class="line">  process.on(<span class="string">'message'</span>, (msg) =&gt; &#123;</span><br><span class="line">    process.send(msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听<br>比如<code>message</code>,<code>error</code>,在工作进程中使用监听事件，可以用 <code>process.on()</code>,主进程中调用，用<code>cluster.on(&#39;...&#39;)</code>,<br>在主进程中，监听特定工作进程发送消息给自己，使用<code>cluster.workers[id].on(&#39;message&#39;, messageHandler);</code><br>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪 http 请求</span></span><br><span class="line">  <span class="keyword">let</span> numReqs = <span class="number">0</span>;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`numReqs = <span class="subst">$&#123;numReqs&#125;</span>`</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算请求数目</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">messageHandler</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.cmd &amp;&amp; msg.cmd === <span class="string">'notifyRequest'</span>) &#123;</span><br><span class="line">      numReqs += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动 worker 并监听包含 notifyRequest 的消息</span></span><br><span class="line">  <span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> id <span class="keyword">in</span> cluster.workers) &#123;</span><br><span class="line">    cluster.workers[id].on(<span class="string">'message'</span>, messageHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Worker 进程有一个http服务器</span></span><br><span class="line">  http.Server(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 master 进程接收到了请求</span></span><br><span class="line">    process.send(&#123; <span class="attr">cmd</span>: <span class="string">'notifyRequest'</span> &#125;);</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="demo实例">demo实例</h2><ol>
<li>多进程简单实现</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'####====START====###'</span>);</span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n &gt; <span class="number">1</span> ? fibo(n - <span class="number">1</span>) + fibo(n - <span class="number">2</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line"> <span class="keyword">var</span> collection = [<span class="number">44</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">43</span>];</span><br><span class="line"> <span class="keyword">var</span> st = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(numCPUs, collection.length); i++) &#123;</span><br><span class="line"> <span class="keyword">var</span> wk = cluster.fork();</span><br><span class="line"> wk.send(collection[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> cluster.on(<span class="string">'fork'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">worker</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`[master] : fork worker <span class="subst">$&#123;worker.id&#125;</span>`</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> cluster.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">worker, code, signal</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`[master] : worker <span class="subst">$&#123;worker.id&#125;</span> died`</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="keyword">var</span> numOfCompelete = <span class="number">0</span></span><br><span class="line"> <span class="built_in">Object</span>.keys(cluster.workers).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line"> cluster.workers[id].on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`[master] receive message from [worker <span class="subst">$&#123;id&#125;</span>]: <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line"> numOfCompelete++;</span><br><span class="line"> <span class="keyword">if</span> (numOfCompelete === collection.length) &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`[master] finish all work and using <span class="subst">$&#123;<span class="built_in">Date</span>.now() -</span></span></span><br><span class="line"><span class="string"><span class="subst"> st&#125;</span> ms`</span>);</span><br><span class="line"> cluster.disconnect();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`[worker <span class="subst">$&#123;cluster.worker.id&#125;</span>] receive msg <span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">var</span> st = <span class="built_in">Date</span>.now();</span><br><span class="line"> <span class="keyword">var</span> result = fibo(msg);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`[worker <span class="subst">$&#123;cluster.worker.id&#125;</span>] finish work and using</span></span><br><span class="line"><span class="string"> <span class="subst">$&#123;<span class="built_in">Date</span>.now() - st&#125;</span> ms`</span>);</span><br><span class="line"> process.send(result);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子完成了创建多进程，子进程执行完成后和主进程通信的功能。</p>
<ol>
<li>主进程：主进程监听了<code>fork, exit</code>方法，创建工作进程后，通过<code>message</code>方法监听每个进程发送给自己的消息。当所有工作进程都发送消息给主进程后，主进程关闭进程。</li>
<li>工作进程： 监听消息，执行任务，并将执行结果send给主进程。执行完任务后，工作进程会正常退出。</li>
</ol>
<p>本例子只是用于学习理解的简单demo,还存在很多问题,代码执行后会发现<code>####====START====###</code>会执行4次，不是我们想要的结果。后续下篇继续。</p>
<h2 id="参考">参考</h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-nodejs-practice/index.html" target="_blank" rel="noopener">Node.js 多进程实战</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>node 多进程基础学习及demo<br>]]>
    
    </summary>
    
      <category term="node" scheme="https://shirleyYing.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vue 初探]]></title>
    <link href="https://shirleyYing.com/2018/02/25/vue-newer/"/>
    <id>https://shirleyYing.com/2018/02/25/vue-newer/</id>
    <published>2018-02-25T13:49:30.000Z</published>
    <updated>2018-02-25T14:00:26.166Z</updated>
    <content type="html"><![CDATA[<p>vue初学，读文档总结，间有一些思考和与React的比较<br><a id="more"></a></p>
<h2 id="计算属性">计算属性</h2><p>计算属性方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// a computed getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` points to the vm instance</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>method方式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Reversed message: <span class="string">"&#123;&#123; reversedMessage() &#125;&#125;"</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">methods: &#123;</span></span><br><span class="line"><span class="regexp">  reversedMessage: function () &#123;</span></span><br><span class="line"><span class="regexp">    return this.message.split('').reverse().join('')</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>一个强大的功能，将对某数据的处理函数作为该属性的get函数。简单应用场景下，利用缓存，可以替代method，并且，vue.js会根据数据是否变化来判断是否执行该函数，减少执行次数。但因此也会有缓存问题，如果不希望利用缓存，使用method方法</p>
<h2 id="class与style绑定">class与style绑定</h2><ol>
<li>都可以使用对象和数组的方式写入，对象方式可以根据key的value的布尔值，来确定是否使用该class，实现了classname的功能，比较好用</li>
<li>绑定style时，vue.js会自动添加前缀。<blockquote>
<p>当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀。</p>
</blockquote>
</li>
</ol>
<h2 id="列表渲染">列表渲染</h2><ol>
<li><code>v-for</code> 用于对象，数组的遍历渲染，替代 map函数</li>
</ol>
<h2 id="条件渲染">条件渲染</h2><ol>
<li>给出 <code>v-if</code>,<code>v-else</code>,<code>v-if-else</code>,不用在return中包裹三目运算符，或者写很多个return了</li>
<li><code>v-show</code>和<code>v-if</code>效果相同，唯一的区别是前者会做dom渲染，只是控制display属性，后者则完全不做渲染，看实际需求使用 </li>
<li>元素高效复用，不会重新渲染，比如input，若切换tab，不想共用之前的input填值，给元素设置不同的key</li>
</ol>
<h2 id="使用-v-on-绑定自定义事件">使用-v-on-绑定自定义事件</h2><p>父组件可以在使用子组件的地方直接用 <code>v-on</code> 来监听子组件触发的事件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter-event-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementCounter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#counter-event-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.total += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在子组件中，给button的click事件绑定了一个自定义函数，函数中触发另一个叫‘increment’的函数<br>在父组件中使用<code>v-on</code>监听了‘increment’，执行<code>incrementTotal</code>函数<br>这种方式比react将父组件的函数以props的方式传递下去，在子组件的对应触发函数中，使用 <code>this.props.fun()</code>来执行感觉高明许多，至少从代码上看，简洁明了，减少了一些props的传递</p>
<h2 id="组件">组件</h2><p>组件分为全局注册和局部注册，全局注册就是根组件，局部的就是父组件中包含的子组件，常用于公共组件。区别于react的直接引用，vue需要注册后，用<code>&lt;xx-component&gt;</code> 标签的方式引用</p>
<p>注册方式如下：</p>
<ol>
<li>全局<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;div id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &lt;my-component&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>渲染为：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"example"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span>&gt;A custom component!&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>局部<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; 将只在父组件模板中可用</span></span><br><span class="line">    <span class="string">'my-component'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="动态prop">动态prop</h2><p><code>v-bind</code></p>
<p>与绑定到任何普通的 HTML 特性相类似，我们可以用 v-bind 来动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件</p>
<h2 id="插槽">插槽</h2><p>使用特定标签<code>&lt;slot&gt;</code>,分为单个和具名两种<br>除非子组件模板包含至少一个 <slot> 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。可用于占位。loading状态，错误信息的处理。与react的不同在于，react需要使用三目运算符，根据状态判断加载哪段dom，加载和错误状态都是写在一个组件中的。而插槽需要写在子组件中，内容由父组件传入，用法其实类似react的<code>children</code>。区别在于</slot></p>
<p>用法如下<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my-component</span></span><br><span class="line"><span class="params">&lt;div&gt;</span></span><br><span class="line">  <span class="params">&lt;h2&gt;</span>我是子组件的标题<span class="params">&lt;/h2&gt;</span></span><br><span class="line">  <span class="params">&lt;slot&gt;</span></span><br><span class="line">    只有在没有要分发的内容时才会显示。</span><br><span class="line">  <span class="params">&lt;/slot&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="params">&lt;div&gt;</span></span><br><span class="line">  <span class="params">&lt;h1&gt;</span>我是父组件的标题<span class="params">&lt;/h1&gt;</span></span><br><span class="line">  <span class="params">&lt;my-component&gt;</span></span><br><span class="line">    <span class="params">&lt;p&gt;</span>这是一些初始内容<span class="params">&lt;/p&gt;</span></span><br><span class="line">    <span class="params">&lt;p&gt;</span>这是更多的初始内容<span class="params">&lt;/p&gt;</span></span><br><span class="line">  <span class="params">&lt;/my-component&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>vue初学，读文档总结，间有一些思考和与React的比较<br>]]>
    
    </summary>
    
      <category term="vue" scheme="https://shirleyYing.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浏览器缓存原理]]></title>
    <link href="https://shirleyYing.com/2018/01/31/browser-cache/"/>
    <id>https://shirleyYing.com/2018/01/31/browser-cache/</id>
    <published>2018-01-31T14:13:31.000Z</published>
    <updated>2018-01-31T14:14:45.578Z</updated>
    <content type="html"><![CDATA[<p>http1中利用缓存机制可以节约http请求数量，减少请求数据<br><a id="more"></a><br>弱缓存（协商缓存）<br>1.第一次请求， 服务端通过 last-Modified 或 Etag标记实体</p>
<p>再次发起请求，带上If-Modified-Since: 上次 Last-Modified 的内容或If-None-Match: 上次 ETag 的内容，询问服务端资源是否过期。（服务端此时会对比该文件在服务器上的last-modified和Etag，若没有变化，则表示没有过期）</p>
<p>没有过期，直接返回一个状态码为 304、正文为空的响应，告知浏览器使用本地缓存(可以节约返回数据)</p>
<p>过期，返回资源，状态码200，新的last-modified，ETag，和正文。</p>
<p>用两个字段完成标识的意义是？</p>
<p>last-modified有问题，第一，只能精确到秒，第二，负载均衡算法中，各机器读到的文件修改时间不一致，会导致文件无故失效或着得不到更新。ETap是由服务端生成的摘要，更准确。</p>
<p>强缓存<br>用 expire 和cache-control（max-age= xxx） 前者规定文件到期时间，后者规定时间段。expire会依赖客户端时间，cache-control是相对时间，更准确一点，若两者同时设定 cache-control会覆盖expire</p>
<p>浏览器刷新清缓存规则<br>F5(cmd+r):清楚一般缓存，就是弱缓存，可能看到304</p>
<p>control+F5(shift+cmd+r):强制刷新，强刷会忽略浏览器所有缓存（并且请求头会携带 Cache-Control:no-cache 和 Pragma:no-cache，用来通知所有中间节点忽略缓存）。只有从地址栏或收藏夹输入网址、点击链接等情况下，浏览器才会使用强缓存。</p>
<p>综合使用<br>一般服务端返回的头部都会带上上述字段，那是如何配合使用的呢？</p>
<p>浏览器缓存流程<br>第一次发起请求（www.baidu.com）</p>
<p>request header：无</p>
<p>response header：status：200，last-modified:xxx,ETag:’xxx’,cache-control:max-age=3600</p>
<p>第二次发起同样的请求（浏览器刷新）</p>
<p>根据cache-control判断是否使用缓存，若未过期，不向服务端发起请求，如图</p>
<p>图1<br>若过期，则向服务端发起请求，服务端端根据last-modified和ETag判断文件是否有改动，若没有，则返回304，浏览器继续使用缓存</p>
<p>若文件有改动，则返回200，新的last-modified，ETag 以及正文</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>http1中利用缓存机制可以节约http请求数量，减少请求数据<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[HSTS详解-让信息传递更安全]]></title>
    <link href="https://shirleyYing.com/2018/01/31/hsts/"/>
    <id>https://shirleyYing.com/2018/01/31/hsts/</id>
    <published>2018-01-31T14:10:46.000Z</published>
    <updated>2018-01-31T14:12:49.506Z</updated>
    <content type="html"><![CDATA[<p>http站点重定向问题优化<br><a id="more"></a><br>随着网络信息传输安全越来越被重视，https越来越普及，大量网站开始全面部署https。为了做到无痛切换，旧的<code>http://</code>必须要保持能够访问，比如，用户直接输入url进入网站，或者保存了之前使用http协议的书签，直接点击链接进入。那怎么办呢？最简单的办法就是使用302重定向，服务端返回302，在<code>location</code>中设置新的<code>https</code>的网址，浏览器再一次发起请求。像这样</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3301631-a9066e5a8c88fafc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络请求.png"><br>这样的方式存在两点不足：</p>
<ol>
<li>第一个请求是明文，若包含敏感信息，容易泄露，很难抵御SSL剥离攻击。</li>
<li>第一个请求无效，浪费了网络请求</li>
</ol>
<p><strong>SSL剥离攻击</strong>，就是利用用户很少直接在地址栏输入<code>https://</code>，用户总是通过点击链接或<strong>3xx重定向</strong>，从HTTP页面进入HTTPS页面,攻击利用302重定向，将所有https的重定向链接修改为http，从而阻止建立https的安全链接。为了解决这一问题，互联网工程任务组发布了一个互联网安全策略机制：HSTS-HTTP严格传输安全。下面，让我们一探究竟。</p>
<h2 id="含义">含义</h2><p>网站选择使用HSTS策略，来让浏览器强制使用HTTPS会话劫持风险。</p>
<h2 id="工作原理">工作原理</h2><p>该策略主要依靠服务端实现，当客户端(浏览器)通过<code>https</code>发出请求时，服务端在响应头中包含<code>Strict-Transport-Security</code>字段，例如：<code>Strict-Transport-Security: max-age =31536000</code></p>
<p>这意味着：</p>
<ol>
<li>在接下来的一年中（max-age），所有通过http访问www.example.com及子域名时，比如，访问<code>http://www.example.com</code>浏览器应当自动将 http 转写成 https，使用307 Internal Redirect ，直接向<code>https://www.example.com/</code> 发送请求。</li>
<li>在接下来的一年中，如果 example.com 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站</li>
</ol>
<p>好处是显而易见的：</p>
<ol>
<li>避免SSL剥离攻击。<strong>只要浏览器曾经与服务器创建过一次安全连接</strong>，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。</li>
<li>避免假冒证书攻击。如果中间人使用自己的自签名证书来进行攻击，浏览器会给出警告，但是许多用户会忽略警告。HSTS解决了这一问题，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。</li>
</ol>
<p>看到这里，或许你也发现了，HSTS还有一点没有解决：用户首次访问某网站怎么办？还有办法：浏览器预置HSTS域名列表（HSTS preload list）</p>
<h2 id="HSTS_preload_list">HSTS preload list</h2><h3 id="含义-1">含义</h3><p>HSTS preload list是Chrome浏览器中的HSTS预载入列表，在该列表中的网站，使用Chrome浏览器访问时，会自动转换成HTTPS。Firefox、Safari、Edge浏览器也在采用这个列表。</p>
<h3 id="使用">使用</h3><p>加入HSTS preload list不但不麻烦，而且Chrome也鼓励HTTPS网站能够主动加入。申请的方法和需要满足的条件在<a href="https://hstspreload.appspot.com网站上都有具体说明。" target="_blank" rel="noopener">https://hstspreload.appspot.com网站上都有具体说明。</a><br>服务端返回字段需要满足以下条件：</p>
<ul>
<li><code>Strict-Transport-Security</code> max-age至少需要18周，10886400秒</li>
<li>必须指定includeSubdomains参数</li>
<li>必须支持preload参数<br>例如：<code>Strict-Transport-Security “max-age=31536000; includeSubDomains; preload</code></li>
</ul>
<h2 id="参考">参考</h2><p><a href="https://blog.wilddog.com/?page_id=1493" target="_blank" rel="noopener">解决缺陷，让HSTS变得完美</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>http站点重定向问题优化<br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 模块加载机制]]></title>
    <link href="https://shirleyYing.com/2018/01/08/es6-modules-load/"/>
    <id>https://shirleyYing.com/2018/01/08/es6-modules-load/</id>
    <published>2018-01-08T14:53:49.000Z</published>
    <updated>2018-01-31T12:07:50.480Z</updated>
    <content type="html"><![CDATA[<p>近来在工作中需要使用angular，并且使用了一个表格组件，对，juqery的插件datatable，遇到了文件引用问题。才发现其实自己还没有很了解ES6。趁此机会，又去了解了一次es6模块加载机制，记录如下。<br><a id="more"></a></p>
<h2 id="探究">探究</h2><h3 id="问题">问题</h3><p>工作中使用了kibana这个 es 的前端库，使用angualr写的。二次开发需要用到表格，就选了<code>angular-datatable</code>，就是用angular的写法封装了jquery的datatable 插件。但是，搞不懂angular的逻辑，居然，包了一层还需要自己引入datatable插件。直接import就不管用。运行起来就报datatable找不到的错误。</p>
<h3 id="原因">原因</h3><p>源码中直接使用了datatable组件，这也就是说，angular-datatable默认全局下有datatable对象。这确实是之前传统juqery插件的用法，用script标签引用插件进来，都是挂在window对象上的。但是对于es6模块加载的方式，import的对象都是对当前文件有用的局部对象，所以<code>import datatables from &#39;datatables.net&#39;</code> 的方式，是无效的。需要自己挂载在window对象上。</p>
<p>另外一种方式。就是以文件方式引入 <code>import &#39;../node_modules/datatables.net&#39;</code>这种方式会执行改文件，文件中有挂载到window对象上的逻辑，所以只要执行了。也会实现挂载到window对象上的效果。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window<span class="selector-class">.datatables</span> = datatables</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>近来在工作中需要使用angular，并且使用了一个表格组件，对，juqery的插件datatable，遇到了文件引用问题。才发现其实自己还没有很了解ES6。趁此机会，又去了解了一次es6模块加载机制，记录如下。<br>]]>
    
    </summary>
    
      <category term="ES6模块加载机制" scheme="https://shirleyYing.com/tags/ES6%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2017总结]]></title>
    <link href="https://shirleyYing.com/2017/12/29/2017-summary/"/>
    <id>https://shirleyYing.com/2017/12/29/2017-summary/</id>
    <published>2017-12-29T13:30:21.000Z</published>
    <updated>2018-01-31T12:04:34.669Z</updated>
    <content type="html"><![CDATA[<p>年终总结<br><a id="more"></a></p>
<h3 id="关于工作">关于工作</h3><p>  工作上平平常常，没什么出彩的事，经历了转岗，背了差绩效。本来以为铁打的营盘流水的兵，来来去去不是很正常的事吗。结果，却比意料中难了许多，恶心了许多。曾经敬佩，喜欢的人啊，没想到最后人设崩塌，还能因为什么呢？因为自己的利益啊。真真假假，看不清楚。总之是走了，就向前看吧。</p>
<p>  到了新的地方，做出一些成绩来。好好努力，买股票，买包买口红</p>
<h3 id="关于学习">关于学习</h3><p>这一年，学习放松了很多，也花时间看了一些东西但是看完就完了，没有输出，感觉像是没有看。<br>做的东西太少，执行力太差。<br>学做了一些node的东西，也就仅限于搭了一个web服务。其他的啥也没做，还是皮毛。<br>但总的来说，确实是比去年好一些了吧。不再害怕遇到问题，不再逃避，心中有了一些方法和感觉。做起来的主观感受好了很多。</p>
<h3 id="关于生活">关于生活</h3><ol>
<li>养的多肉都死了，最后还是死在了夏天，现在尸骨无存，飘散到风中了吧</li>
<li>买了好多口红，屯了好多粉底。导致想买的买不了。</li>
<li>买了很贵的护肤品，最后发现还是早点睡觉最管用。每天坚持用薏仁水湿敷，确实看到了一点效果。</li>
<li>冬天买了豆浆机天天早上打豆浆，断断续续有两个多月吧，生发大业还是收效甚微。导致我不再敢染烫。现在剪了个小学生头…</li>
</ol>
<h3 id="关于旅行">关于旅行</h3><h5 id="湖南小龙虾">湖南小龙虾</h5><p>土豪前部门季度团建，对湖南的记忆就只有文和友小龙虾，和一个忘了名字的但是很有名的臭豆腐。在烈日下包车红色之旅一日游，去了毛主席的家乡还是那里，那个村的入口修的有高铁站那么大，但是就是一个高铁站版的门楼牌坊。大巴不能进去，必须换成他们的车。换了毛式公交又坐了20多分钟的车，看到了很多毛式红烧肉。但是我们没吃，吃了一个巨难吃的团餐。后面的事情都不记得了，就记得热。应该有30度。</p>
<p>然后就是在酒店叫小龙虾的外卖，一屋子女生讲了很多八卦。</p>
<h5 id="内蒙古骑马">内蒙古骑马</h5><p>又是一次团建，去了内蒙古，但是并没有草原，和烤全羊。</p>
<p>那个草原都不好意思拍照，还不如深圳湾公园，本身那个地方水草就不丰美，而且去的时候不是雨季。我们拍照都往上拍哈哈哈。去了就告诉我们骑马要另交钱，结果就交了800块吧好像。但是确实带我们在马上奔驰了半个多小时吧，只是小跑，但是马真的好高啊，它颠个小碎步我们都要吓坏了。摔下来肯定骨折，而且真的屁股要被颠成八瓣了，好累。一路都在想，古装戏里那些策马奔腾真是不容易啊，屁股痛啊。<br>下午看了个表演后，自由活动，我们又去骑马了， 这次叫跑马，真的是跑的！半个小时200块吧？还是一百多不记得了。哇，超爽，真的是前蹄并一起那种大跨步跑起来，整个人要夹紧马肚子站在脚蹬上，要是坐在上面，就要被甩掉了。、</p>
<p>后来又去了沙漠（假的）,住了据说很贵的莲花沙漠酒店，但是吧，没啥印象，酒店里的泳池水很脏，没有人游泳。也没有美女。<br>也没有看到日出。</p>
<h5 id="马来仙仙仙本那">马来仙仙仙本那</h5><p>年度最惊艳之旅，第一次见到辣么蓝，辣么清的大海。以前我都以为那都是电视里的，现实中不存在的。真是贫穷限制了我的想象。第一次深潜，并且吃到了超便宜，超大的皮皮虾以及各种不知道啥名字的海鲜</p>
<h5 id="计划之中的巴厘岛">计划之中的巴厘岛</h5><p>存在在计划中，因为巴厘岛火山爆发了…,上一次爆发是在50年前。</p>
<h3 id="关于计划">关于计划</h3><ol>
<li>健身，然后去拍一套照片，留下25岁青春的影子</li>
<li>学习，github绿起来，坚持笔记输出，不要再次经历无助，只能被欺负并不能做什么的无奈。可以有更多的话语权。</li>
<li>学会做一桌子菜。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>年终总结<br>]]>
    
    </summary>
    
      <category term="life" scheme="https://shirleyYing.com/tags/life/"/>
    
      <category term="life" scheme="https://shirleyYing.com/categories/life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[new life]]></title>
    <link href="https://shirleyYing.com/2017/12/29/new-life/"/>
    <id>https://shirleyYing.com/2017/12/29/new-life/</id>
    <published>2017-12-28T16:01:47.000Z</published>
    <updated>2018-01-31T12:06:00.266Z</updated>
    <content type="html"><![CDATA[<p>生活琐事<br><a id="more"></a></p>
<h1 id="生活琐事">生活琐事</h1><p>今天终于把15年搭的博客源码找回来了，工作一年半，确实没有怎么写东西，想起来了就东写一篇系写一篇。</p>
<p>总是要制定不切实际的计划，然后意料之中又无比难受的放弃，并且否定自己。曾经想写个自己的博客前后台系统。放到腾讯云上，<br>但是，环境折腾了一晚上，就不了了之了。还是先找个地方写东西，其他的慢慢折腾。记录是一定要有的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>生活琐事<br>]]>
    
    </summary>
    
      <category term="life" scheme="https://shirleyYing.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录--一个简单的数据封装]]></title>
    <link href="https://shirleyYing.com/2016/06/02/data-processing/"/>
    <id>https://shirleyYing.com/2016/06/02/data-processing/</id>
    <published>2016-06-02T04:25:26.000Z</published>
    <updated>2018-01-27T13:35:01.767Z</updated>
    <content type="html"><![CDATA[<h1 id="记录–一个简单的数据封装">记录–一个简单的数据封装</h1><a id="more"></a>
<h3 id="数据库返回的数据格式：">数据库返回的数据格式：</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data=[&#123;</span><br><span class="line"><span class="symbol">    knowledge_point:</span> <span class="string">"网页设计与制作"</span>,</span><br><span class="line"><span class="symbol">    type_name:</span> <span class="string">"单选"</span>,</span><br><span class="line"><span class="symbol">    count:</span> <span class="number">70</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">    knowledge_point:</span> <span class="string">"网页设计与制作"</span>,</span><br><span class="line"><span class="symbol">    type_name:</span> <span class="string">"多选"</span>,</span><br><span class="line"><span class="symbol">    count:</span> <span class="number">30</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="需要的数据格式">需要的数据格式</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data= &#123;</span><br><span class="line"><span class="symbol">    knowledge_point:</span> <span class="string">"网页设计与制作"</span>,</span><br><span class="line"><span class="symbol">    sum:</span> <span class="number">100</span>,</span><br><span class="line"><span class="symbol">    types:</span> [&#123;</span><br><span class="line"><span class="symbol">        type_name:</span> <span class="string">"单选"</span>,</span><br><span class="line"><span class="symbol">        count:</span> <span class="number">70</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line"><span class="symbol">        type_name:</span> <span class="string">"多选"</span>,</span><br><span class="line"><span class="symbol">        count:</span> <span class="number">30</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="主要思路">主要思路</h3><p>把相同knowledge_point 的type_name和count合并到数组中，最初的想法是一个for取得knowledge_point，第二个for遍历按照knowledge_point将type_name,count放到对应数组中，第三个for，将第二次for生成的数组塞到对应knowledge_point的对象中。</p>
<p>多次循环效率太低，想用一个for搞定，难点就是第一次得到一个新的knowledge_point时，可以封装，但是第二次遇到时，在循环中不能取得第一次遇到的对象在数组中的位置。想到了对象属性可以直接调用，定义一个<code>foramatData={}</code>将knowledge_point作为key<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foramatData:</span>&#123;</span><br><span class="line">    <span class="string">"网页设计与制作"</span>:&#123;</span><br><span class="line"><span class="symbol">        knowledge_point:</span><span class="string">"网页设计与制作"</span>, </span><br><span class="line"><span class="symbol">        types:</span> [&#123;</span><br><span class="line"><span class="symbol">            type_name:</span> <span class="string">"单选"</span>,</span><br><span class="line"><span class="symbol">            count:</span> <span class="number">70</span></span><br><span class="line">        &#125;]    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在data循环中再次遇到“网页设计与制作”时，调用<code>foramatData[&quot;网页设计与制作&quot;].types.push()</code>,就可将新对象存到对应数组中.<br>然后再查询一次得到sum，放到<code>formatData</code>对应对象中去。<br>代码如下：</p>
<blockquote>
<p>formatData:格式化后的数据<br>questionTypes:存放题目类型列表<br>types:合并后的数组题目类型数组<br>item:types中的一个对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">questionBankList.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> questionTypes = [];</span><br><span class="line">        <span class="keyword">var</span> formatDatas = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> types = [];</span><br><span class="line">            <span class="keyword">var</span> item=&#123;&#125;;</span><br><span class="line">            item.type_name = data[i].question_type;</span><br><span class="line">            item.count = data[i].count;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> knowledge_point = data[i].knowledge_point;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (questionTypes.indexOf(knowledge_point) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                questionTypes.push(knowledge_point);</span><br><span class="line">                formatDatas[knowledge_point] = &#123;</span><br><span class="line">                    knowledge_point: knowledge_point,</span><br><span class="line">                    types:types</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            formatDatas[knowledge_point].types.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> oneQuestionBankSum = studentPaper.getOneQuestionBankSum();   </span><br><span class="line">        oneQuestionBankSum.then(<span class="function"><span class="keyword">function</span>(<span class="params">sum</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; sum.length; i++) &#123;</span><br><span class="line">                    formatDatas[sum[i].knowledge_point].sum= sum[i].sum;</span><br><span class="line">                &#125;  </span><br><span class="line">                res.json(formatDatas);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="记录–一个简单的数据封装">记录–一个简单的数据封装</h1>]]>
    
    </summary>
    
      <category term="record" scheme="https://shirleyYing.com/tags/record/"/>
    
      <category term="js" scheme="https://shirleyYing.com/categories/js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用box-sizing 解决移动端不同屏幕手机适配问题]]></title>
    <link href="https://shirleyYing.com/2016/01/10/box-sizing/"/>
    <id>https://shirleyYing.com/2016/01/10/box-sizing/</id>
    <published>2016-01-10T09:45:22.000Z</published>
    <updated>2018-01-27T13:35:01.767Z</updated>
    <content type="html"><![CDATA[<h1 id="用box-sizing_解决移动端不同屏幕手机适配问题">用box-sizing 解决移动端不同屏幕手机适配问题</h1><p>手机页面由于要适配不同屏幕大小。所以宽度都要用百分数，如果遇到占满整个屏幕宽度，还是有border的div要怎么办？</p>
<a id="more"></a>
<p>css3里面的一个属性：<code>box-sizing</code> 直接解决了问题。<br>比方说这样一个页面。<br><img src="/imgs/mobile.jpg" alt="view"><br>移动端的h5页面，需要设配不同屏幕尺寸，但是<code>width</code> 又是不算border的。那也就是说<code>width:100%</code> 就不能用了，但是我怎么知道有多少尺寸等着我啊。多次尝试未果，打算用背景图来解决。牛逼闪闪的师父给了我这个建议：<strong>box-sizing</strong>。</p>
<p>box-sizing：content-box| border-box</p>
<p>content-box: 就是现代浏览器盒模型的计算方法，width就是你自己写的width，padding，border都不算在里面。</p>
<p>border-box： width是总的占的尺寸。所有都算。</p>
<p>像这个页面，上半部分绿色的框需要占满整个屏幕，下半部分press按钮又需要在下半部分的高度里垂直居中。刚刚的box-sizing搞定了上半部分。下半部分的垂直居中，同样遇到了 <code>height</code> 不固定的问题。用flex做垂直居中是个比较好的选择。同样需要用到  <code>box-sizing</code></p>
<h3 id="解决方案">解决方案</h3><p>把上半部分的高度用px固定死当然会适配几种尺寸，然后下半部分用一个div。绝对定位，占满整个屏幕，然后padding-top把它的位置调下来。</p>
<p>box-sizing 又一次起作用了。如果不加box-sizing，你的高度就要爆掉了。然后flex垂直居中，完美。</p>
<p>代码就不上了，比较懒~</p>
<h3 id="另一个问题">另一个问题</h3><p>做到这还遇到了另外一个问题：div 层次的问题。<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.top</span>&#123;</span><br><span class="line">    <span class="string">.loading</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">.bottom</span>&#123;</span><br><span class="line">    <span class="string">.button</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先效果是先出loading几秒，然后淡入首页，但是loading出现的时候，下面的bottom块也在。第一个想法肯定是加z-index了，但是，加了没用。<br>原因：<br>它放在top里面。top和bottom是平级的。也就是说，用了绝对定位后，bottom就在top前面了。top里面的loading index再高，父元素不给力，也是没办法的。所以，在top上加<code>z-index</code> 就好了。之前看过一篇特别棒的写 z-index的文章，贴在这里。<br>[<a href="http://www.w3cplus.com/css/what-no-one-told-you-about-z-index.html" target="_blank" rel="noopener">http://www.w3cplus.com/css/what-no-one-told-you-about-z-index.html</a>]</p>
<p>第一次做移动端的页面，确实要考虑很多适配问题，之后遇到其他的，继续记录。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="用box-sizing_解决移动端不同屏幕手机适配问题">用box-sizing 解决移动端不同屏幕手机适配问题</h1><p>手机页面由于要适配不同屏幕大小。所以宽度都要用百分数，如果遇到占满整个屏幕宽度，还是有border的div要怎么办？</p>]]>
    
    </summary>
    
      <category term="css3" scheme="https://shirleyYing.com/tags/css3/"/>
    
      <category term="html5" scheme="https://shirleyYing.com/tags/html5/"/>
    
      <category term="mobile" scheme="https://shirleyYing.com/tags/mobile/"/>
    
      <category term="terminal" scheme="https://shirleyYing.com/tags/terminal/"/>
    
      <category term="css3" scheme="https://shirleyYing.com/categories/css3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[flex属性介绍]]></title>
    <link href="https://shirleyYing.com/2015/12/13/flex/"/>
    <id>https://shirleyYing.com/2015/12/13/flex/</id>
    <published>2015-12-12T16:00:00.000Z</published>
    <updated>2018-01-31T12:06:36.271Z</updated>
    <content type="html"><![CDATA[<p>flex学习笔记<br><a id="more"></a></p>
<h1 id="flex学习笔记">flex学习笔记</h1><h2 id="前言">前言</h2><p>flexmodel ：自适应盒模型<br>分为主轴和侧轴，也就是横轴和侧轴。用来决定子元素的排列方式。<br><img src="/imgs/CSS3-Flexbox-Model.jpg" alt="CSS3-Flexbox-Model"></p>
<p>PS:最近在做的页面主要以一列展示为主，所以主要用到了垂直居中相关的内容。和以前用margin的方式相比，确实好用太多。本文所写属性也和垂直居中相关。还有些属性并没有写全。更多属性，请参考：<a href="https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties" target="_blank" rel="noopener">a-visual-guide-to-css3-flexbox-properties</a>.<br><strong>支持情况：</strong></p>
<p>Chrome 29+<br>Firefox 28+<br>Internet Explorer 11+<br>Opera 17+<br>Safari 6.1+ (prefixed with -webkit-)<br>Android 4.4+<br>iOS 7.1+ (prefixed with -webkit-)<br>可以在 <a href="http://caniuse.com/flexbox" target="_blank" rel="noopener">here</a>看到更多细节和兼容性的内容。</p>
<h2 id="属性介绍">属性介绍</h2><h3 id="flex">flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来开启盒模型，用在flex容器中。</p>
<h3 id="inline-flex">inline-flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-inline-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像内联元素一样使用它。<br>以上两个需要在父元素中使用，它的直系孩子会自动成为flex文档流，成为可伸缩的项目。</p>
<h3 id="flex-direction">flex-direction</h3><p>定义内部文档流的排序方向。取值：row，column，row-reverse，column-reverse<br>默认值: <code>row</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-flex-direction</span>: row; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>:         row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flexbox-flex-direction-row：</p>
<p><img src="/imgs/flexbox-flex-direction-row.jpg" alt="flexbox-flex-direction-row"><br>flexbox-flex-direction-column:</p>
<p><img src="/imgs/flexbox-flex-direction-column.jpg" alt="flexbox-flex-direction-column"></p>
<h3 id="flex-wrap">flex-wrap</h3><p>定义是否换行。<br>values:<code>wrap-reverse</code>, <code>wrap</code>.<br>default values:<code>nowarp</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-flex-direction</span>: row; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>:         row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="justify-content">justify-content</h3><p>用在容器中定义子元素排列顺序。<br>values:<br><code>flex-start</code>:从主轴开始的位置排列,<br><code>flex-end</code>:从侧轴开始的位置排列,<br><code>center</code>:剧中排列，height延展至父容器，width不延展<br><code>space-between：居中排列，height延展至父容器，width不延展，但是用间距填满主轴方向。</code>space-around<code>：和</code>space-between<code>一样，唯一的不同是每个item 左右两边会有间距。
default values:</code>flex-start`<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-justify-content</span>: flex-start; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">justify-content</span>:         flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flex-start:<br><img src="/imgs/flexbox-justify-content-flex-start.jpg" alt="flexbox-justify-content-flex-start"><br>flex-end:<br><img src="/imgs/flexbox-justify-content-flex-end.jpg" alt="flexbox-justify-content-flex-end"><br>cneter:<br><img src="/imgs/flexbox-justify-content-center.jpg" alt="flexbox-justify-content-center"><br>space-between:<br><img src="/imgs/flexbox-justify-content-space-between.jpg" alt="flexbox-justify-content-space-between"><br>space-around:<br><img src="/imgs/flexbox-justify-content-space-around.jpg" alt="flexbox-justify-content-space-around"></p>
<h3 id="align-item">align-item</h3><p> 定义容器中子元素的垂直（侧轴）对齐方式。可以用于设置子元素的垂直居中。和<code>justify-content</code> 配合使用。前者确定子元素的水平排列方式，后者确定子元素的垂直对齐方式。<br> values:<code>stretch</code>,<code>flex-start</code>,<code>flex-end</code>,<code>center</code>,<code>baseline</code><br> <code>stretch:</code>： 侧轴方向延展。<br> <code>flex-start</code>： 沿侧轴开始的位置排列，靠上<br> <code>flex-end</code>： 沿侧轴结束的位置排列，靠下<br> <code>center</code>：垂直居中<br> <code>baseline</code>：每个item的文字基线对齐。<br>default values: <code>stretch</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">   <span class="attribute">-webkit-align-items</span>: stretch; <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">align-items</span>:         stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stretch:<br><img src="/imgs/flexbox-align-items-stretch.jpg" alt="flexbox-align-items-stretch"><br>flex-start:<br><img src="/imgs/flexbox-align-items-flex-start.jpg" alt="flexbox-align-items-flex-start"><br>flex-end:<br><img src="/imgs/flexbox-align-items-flex-end.jpg" alt="flexbox-align-items-flex-end"><br>center:<br><img src="/imgs/flexbox-align-items-center.jpg" alt="flexbox-align-items-center"><br>baseline：<br><img src="/imgs/flexbox-align-items-baseline.jpg" alt="flexbox-align-items-baseline"></p>
<h2 id="example">example</h2><p>垂直居中的例子：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">justify-content</span> :space-between;</span><br><span class="line">    <span class="attribute">align-items</span>：center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是简单地展示效果，并没有做兼容性考虑。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>flex学习笔记<br>]]>
    
    </summary>
    
      <category term="css3" scheme="https://shirleyYing.com/tags/css3/"/>
    
      <category term="前端" scheme="https://shirleyYing.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="移动端" scheme="https://shirleyYing.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="flex" scheme="https://shirleyYing.com/tags/flex/"/>
    
      <category term="css3" scheme="https://shirleyYing.com/categories/css3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用hexo搭建自己的个人博客]]></title>
    <link href="https://shirleyYing.com/2015/10/07/hexo-bolg-github/"/>
    <id>https://shirleyYing.com/2015/10/07/hexo-bolg-github/</id>
    <published>2015-10-07T13:39:15.000Z</published>
    <updated>2018-05-13T01:43:19.000Z</updated>
    <content type="html"><![CDATA[<p>之前用gitbook发布到github上写笔记，没能找到怎么高亮显示代码块，总觉得不爽，最后还是用了hexo，没想到非常方便，网上教程很多。搭建完成后，也来写一篇当做纪念。</p>
<a id="more"></a>
<h1 id="准备工作">准备工作</h1><ol>
<li>git安装 <code>v 1.9.5</code> </li>
<li>node安装 <code>v 0.4.1</code></li>
<li>hexo安装 <code>v 3.1.1</code></li>
</ol>
<h1 id="搭建">搭建</h1><h2 id="初始化文件夹">初始化文件夹</h2><p>安装完成后，根据自己喜好建立目录（如<code>D:Git\hexo</code>），进入<code>Git Shell</code>切换到该路径下<code>D:Git\hexo</code>执行以下指令,<code>Hexo</code> 将会在指定文件夹中新建所需要的文件,若未指定文件夹，将在当前路径中完成初始化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>启动本地服务器 <code>hexo server</code>  本地查看效果,输入<code>http://localhost：4000</code></p>
<h2 id="更换主题">更换主题</h2><p>使用了pacman的主题 <a href="http://yangjian.me/pacman/hello/introducing-pacman-theme/" target="_blank" rel="noopener">pacman主题介绍</a></p>
<h3 id="遇到的问题">遇到的问题</h3><ol>
<li><p>博客根目录下的config.yml中 没有<code>stylus</code>属性.    在文件最后添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  stylus:</span><br><span class="line">compress: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>代码片段不会高亮显示。在<code>theme/pacman/_config.yml</code> 中添加</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>author.jpg 找不到。路径加一级 <code>author_img: ../img/author.jpg</code> </p>
</li>
</ol>
<h3 id="主题修改">主题修改</h3><h4 id="创建标签和归档">创建标签和归档</h4><p>menu 默认没有启用<code>/tags</code> 和 <code>/categories</code><br>页面，如果需要启用请在博客目录下的source文件夹中分别建立<code>tags</code> 和 <code>categories</code>文件夹每个文件夹中分别包含一个index.md文件。内容为：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layout:</span> <span class="string">tags</span> <span class="string">(或categories)</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span> <span class="string">(或categories)</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<h2 id="编写博客">编写博客</h2><ol>
<li>进入bolg文件夹下  <code>hexo new &quot; article&quot;</code></li>
<li>去source文件下中找到article.md </li>
<li>编写tags 和catagory</li>
<li>写完后，hexo generate</li>
<li>发布 hexo deploy<br>eg：<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tags:</span> [css3, html5, mobile, terminal]</span><br><span class="line">categories: css3</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>常用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br></pre></td></tr></table></figure></p>
<p>发布显示更多,在你觉得适合的位置插入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="插件安装">插件安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一键发布到github上</span></span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line"><span class="comment"># rss 插件</span></span><br><span class="line">$ npm install hexo-generator-feed</span><br><span class="line"><span class="comment"># 站点地图插件</span></span><br><span class="line">$ npm install hexo-generator-sitemap</span><br></pre></td></tr></table></figure>
<h2 id="插件设置">插件设置</h2><h3 id="rss设置">rss设置</h3><ol>
<li><p>编辑根目录下的<code>_config.yml</code>,添加</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line"><span class="bullet">- </span>hexo-generator-feed</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>themes/pacman/_config.yml</code>中，编辑 <code>rss: /atom.xml</code></p>
</li>
<li>在<code>themes/pacman/layout/_partial/header.ejs</code>中，<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>之间，添加一样代码<span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/atom.xml"</span>&gt;</span>RSS<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="sitemap设置">sitemap设置</h3><ol>
<li>编辑根目录下的<code>_config.yml</code>,添加<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins:</span><br><span class="line"><span class="bullet">- </span>hexo-generator-sitemap</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="发布到github">发布到github</h2><ol>
<li>在github上建立仓库，仓库名必须为『your_user_name.github.io』</li>
<li>安装<code>hexo-deployer-git</code>插件，在根目录下的<code>_config.yml</code>,添加<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:shirleyYing/shirleyYing.github.io.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意</strong>: <code>type:git</code> 不能是<code>github</code><br>插件只是将publish文件夹的内容发布到github对应仓库中去。</p>
<h2 id="参考">参考</h2><p>[<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a>]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前用gitbook发布到github上写笔记，没能找到怎么高亮显示代码块，总觉得不爽，最后还是用了hexo，没想到非常方便，网上教程很多。搭建完成后，也来写一篇当做纪念。</p>]]>
    
    </summary>
    
      <category term="hexo" scheme="https://shirleyYing.com/tags/hexo/"/>
    
      <category term="pacman" scheme="https://shirleyYing.com/tags/pacman/"/>
    
      <category term="blog" scheme="https://shirleyYing.com/tags/blog/"/>
    
      <category term="tools" scheme="https://shirleyYing.com/categories/tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端ps工具使用技巧]]></title>
    <link href="https://shirleyYing.com/2015/10/07/ps-cut/"/>
    <id>https://shirleyYing.com/2015/10/07/ps-cut/</id>
    <published>2015-10-07T12:53:57.000Z</published>
    <updated>2018-01-27T13:35:01.768Z</updated>
    <content type="html"><![CDATA[<h1 id="前端ps工具使用技巧">前端ps工具使用技巧</h1><a id="more"></a>
<p>使用工具：<strong> PS cc </strong></p>
<h2 id="PS快捷键">PS快捷键</h2><h3 id="操作图层">操作图层</h3><blockquote>
<p>v 移动图层 alt +鼠标左键拖动，复制并移动图层，制作雪碧图时很好用。 ctrl+T 缩放当前图层（自由变换模式）</p>
</blockquote>
<h3 id="切片技巧：">切片技巧：</h3><ol>
<li><p>v 用ctrl选中两个或多个图层，ctrl+E 合并图层<br>alt +双击左键 弹出切片选项，设定切片宽高，并且可以命名。<br>调整切片位置，用键盘上下左右键可以精确调整</p>
</li>
<li><p>切sprite图时，通常新建一个文件存放，可以直接在原文件上选中图层复制后，拖到新的文件中，<strong>图像–》裁切–》基于透明像素</strong> 可以去掉多余的透明背景。</p>
</li>
</ol>
<h3 id="工具类切换">工具类切换</h3><ol>
<li>c       切片</li>
<li>v      移动图层</li>
<li>i 吸管，标尺 </li>
<li>h  抓手工具</li>
<li>同组工具切换 shift +字母： shift+i    切换吸管和标尺**</li>
</ol>
<p>参考文章<a href="http://www.w3cfuns.com/article-5600020-1-1.html" target="_blank" rel="noopener">关于web切图你需要知道的几件事情</a></p>
<h2 id="切图保存格式问题">切图保存格式问题</h2><p>前几天遇到切图保存后有明显锯齿的情况，本来透明背景图保存过后就变了灰色不透明，两个的原因都是因为保存切片格式问题。习惯保存<code>png8</code>，这两种情况保存成<code>png24</code>就ok了。</p>
<hr>
<p><strong> 保存格式大体注意 </strong></p>
<p>jpg对应色彩十分丰富，对比度强烈的图片<br>png8 对应小图标，纯色为主的图片，<br>png24 是 有2的24方中颜色值的意思，颜色粒度更细腻，图片细节处较好。和jpg适用场景相似，但是，同样图片，jpg保存的要比png24 的小。</p>
<p>具体差异淘宝ued有篇文章很赞 <a href="http://ued.taobao.org/blog/2010/12/jpg_png/" target="_blank" rel="noopener">图片格式与设计那点事儿</a></p>
<h2 id="PS切图神器">PS切图神器</h2><p><code>Cut And Slice Me</code>  一个ps插件 cs6以上都可以用。试了一下，还挺简单的，但是所有组同时切和子集切这两个不好使，只有单个切得那个好用。</p>
<p>使用教程：<a href="http://www.boxui.com/ui-resource/design-aid/18666.html" target="_blank" rel="noopener">Cut And Slice Me</a></p>
<p>PScc 14.2.1版本可以自动生成切片，也是选中图层就可以生成。也是有那么一点点用。</p>
<p><strong> 这篇ps工具技巧主要围绕切图展开。切图神器都有点鸡肋。个人觉得如果要切小图标的话还是自己拖拽到新文件比较方便。偶尔用一下切图神器也是不错的。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前端ps工具使用技巧">前端ps工具使用技巧</h1>]]>
    
    </summary>
    
      <category term="前端" scheme="https://shirleyYing.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="PScc" scheme="https://shirleyYing.com/tags/PScc/"/>
    
      <category term="切图" scheme="https://shirleyYing.com/tags/%E5%88%87%E5%9B%BE/"/>
    
      <category term="tools" scheme="https://shirleyYing.com/categories/tools/"/>
    
  </entry>
  
</feed>
